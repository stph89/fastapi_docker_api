$ docker-compose build
$ docker-compose up -d
$ docker-compose up
$ docker-compose -f docker-compose.yml up

Comandos para crear la posgres desde cero:
# Build the new image and spin up the two containers: web & db
docker-compose up -d --build --ªpara craer la imagen posgres alpine e instalar las librerias ormar y asyncpg


#Ensure the users table was created:
docker-compose exec db psql --username=fastapi_traefik --dbname=fastapi_traefik

psql (15.1)
Type "help" for help.

fastapi_traefik=# \l
fastapi_traefik=# \c fastapi_traefik
fastapi_traefik=# \dt
fastapi_traefik=# \q

#You can check that the volume was created as well by running:
docker volume inspect nombre_del_proyecto_postgres_data
-->el nombre del proyecto es el nombre de la carpeta o el nombre del proyecto en el docker desktop

#Dockerfile production
Para el despliegue de nuestra aplicación, tenemos que añadir Gunicorn, un servidor WSGI,
para generar instancias de Uvicorn. En lugar de escribir nuestro propio Dockerfile de producción,
podemos aprovechar uvicorn-gunicorn, una imagen Docker pre-construida con Uvicorn y Gunicorn
para aplicaciones web de alto rendimiento mantenida por el autor principal de FastAPI.

#Dcokerfile.prod
Se crea un nuevo Dockerfile llamado Dockerfile.prod para su uso con compilaciones de producción:
The tiangolo/uvicorn-gunicorn:python3.11.1-slim image does much of the work for us.
We just copied over the requirements.txt file, installed the dependencies, and then copied over all the project files.

#docker-compose.prod.yml
Next, create a new compose file called docker-compose.prod.yml for production:
The uvicorn-gunicorn Docker image that we used uses a prestart.sh script to run commands before the app starts.
We can use this to wait for Postgres.

#prestart.sh
Then, add a prestart.sh file to the root of the project:
Update the file permissions locally:
$ chmod +x prestart.sh

Bring down the development containers (and the associated volumes with the -v flag):
# docker-compose down -v

Then, build the production images and spin up the containers:

$ docker-compose -f docker-compose.prod.yml up -d --build
Despliega el compuse.yml
docker-compose -f docker-compose.prod.yml up

# para remover contenedores
$ docker-compose down -v
$ docker-compose -f docker-compose.prod.yml down -v

# Build the new development images and spin up the containers:
$ docker-compose up -d --build

# Navigate to http://fastapi.localhost:8008/. You should see:

# You can test via cURL as well:

$ curl -H Host:fastapi.localhost http://0.0.0.0:8008

# Next, check out the dashboard at fastapi.localhost:8081:
